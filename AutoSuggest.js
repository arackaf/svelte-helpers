import { SvelteComponent, init, safe_not_equal, globals, element, append, set_style, attr, insert, listen, transition_in, space, toggle_class, update_slot, transition_out, detach, run_all, group_outros, check_outros, add_render_callback, create_bidirectional_transition, destroy_each, set_input_value, component_subscribe, create_slot, text, set_data, binding_callbacks } from 'svelte/internal';
import { onMount } from 'svelte';
import escapeRegex from 'escape-string-regexp';
import { spring } from 'svelte/motion';
import { fade } from 'svelte/transition';

/* src/AutoSuggest.svelte generated by Svelte v3.30.0 */

const { document: document_1 } = globals;

function add_css() {
	var style = element("style");
	style.id = "svelte-xuq0mx-style";
	style.textContent = ":root{--svelte-helpers-auto-complete-border-color:lightgray;--svelte-helpers-auto-complete-border-width:1px;--svelte-helpers-auto-complete-border-radius:4px;--svelte-helpers-auto-complete-item-padding:5px;--svelte-helpers-auto-complete-results-max-height:300px;--svelte-helpers-auto-complete-item-hover-background:lightgray;--svelte-helpers-auto-complete-item-hover-cursor:pointer;--svelte-helpers-auto-complete-options-background-color:white}.root.svelte-xuq0mx{display:inline-flex;flex-direction:column}input.svelte-xuq0mx{border:var(--svelte-helpers-auto-complete-border-width) solid var(--svelte-helpers-auto-complete-border-color);border-radius:5px;padding:5px;outline:none}input.open{border-bottom-left-radius:0;border-bottom-right-radius:0}.options-root.svelte-xuq0mx{position:relative}.options-container.svelte-xuq0mx{min-width:calc(100% - 2 * var(--svelte-helpers-auto-complete-border-width));border:var(--svelte-helpers-auto-complete-border-width) solid var(--svelte-helpers-auto-complete-border-color);border-radius:var(--svelte-helpers-auto-complete-border-radius);border-top-left-radius:0;border-top-right-radius:0;position:absolute;left:0;top:calc(-1 * var(--svelte-helpers-auto-complete-border-width));max-height:var(--svelte-helpers-auto-complete-results-max-height);overflow:auto;background-color:var(--svelte-helpers-auto-complete-options-background-color)}ul.svelte-xuq0mx{padding:0;margin:0;display:inline-block}li.svelte-xuq0mx{list-style-type:none;white-space:nowrap;padding:var(--svelte-helpers-auto-complete-item-padding);margin:0}li.result{cursor:var(--svelte-helpers-auto-complete-item-hover-cursor)}li.selected{background-color:var(--svelte-helpers-auto-complete-item-hover-background)}";
	append(document_1.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[40] = list[i];
	child_ctx[42] = i;
	return child_ctx;
}

const get_no_results_slot_changes = dirty => ({});
const get_no_results_slot_context = ctx => ({});

const get_result_slot_changes = dirty => ({
	option: dirty[0] & /*filteredOptions*/ 512
});

const get_result_slot_context = ctx => ({ option: /*option*/ ctx[40] });

// (229:2) {#if open}
function create_if_block(ctx) {
	let div1;
	let div0;
	let ul;
	let div1_transition;
	let current;
	let mounted;
	let dispose;
	let each_value = /*filteredOptions*/ ctx[9];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block(ctx);
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (each_1_else) {
				each_1_else.c();
			}

			set_style(ul, "min-width", /*inputWidth*/ ctx[8] + "px");
			attr(ul, "class", "svelte-xuq0mx");

			set_style(div0, "height", /*animateContainerHeight*/ ctx[10]
			? /*$slideInSpring*/ ctx[11].height + "px"
			: "auto");

			set_style(div0, "width", /*animateContainerHeight*/ ctx[10]
			? /*$slideInSpring*/ ctx[11].width + "px"
			: "auto");

			attr(div0, "class", "options-container svelte-xuq0mx");
			attr(div1, "class", "options-root svelte-xuq0mx");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			if (each_1_else) {
				each_1_else.m(ul, null);
			}

			/*ul_binding*/ ctx[34](ul);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "introstart", opening),
					listen(div1, "introend", /*opened*/ ctx[16]),
					listen(div1, "outrostart", /*closing*/ ctx[17]),
					listen(div1, "outroend", closed)
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selectedIndex, onSelect, filteredOptions, highlightItem, unhighlightItem, displayField, $$scope*/ 136053268) {
				each_value = /*filteredOptions*/ ctx[9];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();

				if (!each_value.length && each_1_else) {
					each_1_else.p(ctx, dirty);
				} else if (!each_value.length) {
					each_1_else = create_else_block(ctx);
					each_1_else.c();
					transition_in(each_1_else, 1);
					each_1_else.m(ul, null);
				} else if (each_1_else) {
					group_outros();

					transition_out(each_1_else, 1, 1, () => {
						each_1_else = null;
					});

					check_outros();
				}
			}

			if (!current || dirty[0] & /*inputWidth*/ 256) {
				set_style(ul, "min-width", /*inputWidth*/ ctx[8] + "px");
			}

			if (!current || dirty[0] & /*animateContainerHeight, $slideInSpring*/ 3072) {
				set_style(div0, "height", /*animateContainerHeight*/ ctx[10]
				? /*$slideInSpring*/ ctx[11].height + "px"
				: "auto");
			}

			if (!current || dirty[0] & /*animateContainerHeight, $slideInSpring*/ 3072) {
				set_style(div0, "width", /*animateContainerHeight*/ ctx[10]
				? /*$slideInSpring*/ ctx[11].width + "px"
				: "auto");
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			add_render_callback(() => {
				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: 150 }, true);
				div1_transition.run(1);
			});

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: 150 }, false);
			div1_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			if (each_1_else) each_1_else.d();
			/*ul_binding*/ ctx[34](null);
			if (detaching && div1_transition) div1_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (250:10) {:else}
function create_else_block(ctx) {
	let li;
	let t;
	let current;
	const no_results_slot_template = /*#slots*/ ctx[28]["no-results"];
	const no_results_slot = create_slot(no_results_slot_template, ctx, /*$$scope*/ ctx[27], get_no_results_slot_context);
	const no_results_slot_or_fallback = no_results_slot || fallback_block_1();

	return {
		c() {
			li = element("li");
			if (no_results_slot_or_fallback) no_results_slot_or_fallback.c();
			t = space();
			attr(li, "class", "svelte-xuq0mx");
		},
		m(target, anchor) {
			insert(target, li, anchor);

			if (no_results_slot_or_fallback) {
				no_results_slot_or_fallback.m(li, null);
			}

			append(li, t);
			current = true;
		},
		p(ctx, dirty) {
			if (no_results_slot) {
				if (no_results_slot.p && dirty[0] & /*$$scope*/ 134217728) {
					update_slot(no_results_slot, no_results_slot_template, ctx, /*$$scope*/ ctx[27], dirty, get_no_results_slot_changes, get_no_results_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(no_results_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(no_results_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (no_results_slot_or_fallback) no_results_slot_or_fallback.d(detaching);
		}
	};
}

// (252:38) No results
function fallback_block_1(ctx) {
	let t;

	return {
		c() {
			t = text("No results");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (248:43) {typeof option === 'string' ? option : option[displayField]}
function fallback_block(ctx) {
	let t_value = (typeof /*option*/ ctx[40] === "string"
	? /*option*/ ctx[40]
	: /*option*/ ctx[40][/*displayField*/ ctx[2]]) + "";

	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*filteredOptions, displayField*/ 516 && t_value !== (t_value = (typeof /*option*/ ctx[40] === "string"
			? /*option*/ ctx[40]
			: /*option*/ ctx[40][/*displayField*/ ctx[2]]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (241:10) {#each filteredOptions as option, index}
function create_each_block(ctx) {
	let li;
	let t;
	let current;
	let mounted;
	let dispose;
	const result_slot_template = /*#slots*/ ctx[28].result;
	const result_slot = create_slot(result_slot_template, ctx, /*$$scope*/ ctx[27], get_result_slot_context);
	const result_slot_or_fallback = result_slot || fallback_block(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[31](/*option*/ ctx[40]);
	}

	function mousemove_handler() {
		return /*mousemove_handler*/ ctx[32](/*index*/ ctx[42]);
	}

	function mouseleave_handler() {
		return /*mouseleave_handler*/ ctx[33](/*index*/ ctx[42]);
	}

	return {
		c() {
			li = element("li");
			if (result_slot_or_fallback) result_slot_or_fallback.c();
			t = space();
			attr(li, "class", "result svelte-xuq0mx");
			toggle_class(li, "selected", /*index*/ ctx[42] == /*selectedIndex*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, li, anchor);

			if (result_slot_or_fallback) {
				result_slot_or_fallback.m(li, null);
			}

			append(li, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "click", click_handler),
					listen(li, "mousemove", mousemove_handler),
					listen(li, "mouseleave", mouseleave_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (result_slot) {
				if (result_slot.p && dirty[0] & /*$$scope, filteredOptions*/ 134218240) {
					update_slot(result_slot, result_slot_template, ctx, /*$$scope*/ ctx[27], dirty, get_result_slot_changes, get_result_slot_context);
				}
			} else {
				if (result_slot_or_fallback && result_slot_or_fallback.p && dirty[0] & /*filteredOptions, displayField*/ 516) {
					result_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (dirty[0] & /*selectedIndex*/ 16) {
				toggle_class(li, "selected", /*index*/ ctx[42] == /*selectedIndex*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(result_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(result_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (result_slot_or_fallback) result_slot_or_fallback.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let input;
	let t;
	let current;
	let mounted;
	let dispose;
	let if_block = /*open*/ ctx[6] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "placeholder", /*placeholder*/ ctx[0]);
			attr(input, "style", /*inputStyles*/ ctx[1]);
			attr(input, "class", "svelte-xuq0mx");
			toggle_class(input, "open", /*open*/ ctx[6]);
			attr(div, "class", "root svelte-xuq0mx");
			toggle_class(div, "open", /*open*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			/*input_binding*/ ctx[29](input);
			set_input_value(input, /*currentSearch*/ ctx[3]);
			append(div, t);
			if (if_block) if_block.m(div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "keydown", /*keyDown*/ ctx[21]),
					listen(input, "input", /*input_input_handler*/ ctx[30]),
					listen(input, "input", /*inputChanged*/ ctx[13]),
					listen(input, "click", /*inputEngaged*/ ctx[12]),
					listen(input, "focus", /*inputEngaged*/ ctx[12]),
					listen(input, "blur", /*inputBlurred*/ ctx[14])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*placeholder*/ 1) {
				attr(input, "placeholder", /*placeholder*/ ctx[0]);
			}

			if (!current || dirty[0] & /*inputStyles*/ 2) {
				attr(input, "style", /*inputStyles*/ ctx[1]);
			}

			if (dirty[0] & /*currentSearch*/ 8 && input.value !== /*currentSearch*/ ctx[3]) {
				set_input_value(input, /*currentSearch*/ ctx[3]);
			}

			if (dirty[0] & /*open*/ 64) {
				toggle_class(input, "open", /*open*/ ctx[6]);
			}

			if (/*open*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*open*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*open*/ 64) {
				toggle_class(div, "open", /*open*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*input_binding*/ ctx[29](null);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function opening() {
	
}

function closed() {
	
}

function instance($$self, $$props, $$invalidate) {
	let $slideInSpring;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { onItemSelected } = $$props;
	let { onBlur } = $$props;
	let { options = [] } = $$props;
	let { placeholder = "" } = $$props;
	let { inputStyles = "" } = $$props;
	let { filterField = "" } = $$props;
	let { displayField = "" } = $$props;
	let { filterByStartsWith = false } = $$props;
	let open = false;
	let inputEl = null;
	let inputWidth;
	let currentSearch = "";
	let filteredOptions = options;
	let selectedIndex = null;
	let focused = false;

	function inputEngaged() {
		$$invalidate(6, open = true);
		focused = true;
	}

	function inputChanged() {
		if (!open) {
			$$invalidate(6, open = true);
		}
	}

	function inputBlurred() {
		$$invalidate(6, open = false);
		focused = false;
		onBlur && onBlur();
	}

	function filterOptions(options) {
		return options.filter(item => new RegExp((filterByStartsWith ? "^" : "") + escapeRegex(currentSearch), "i").test(typeof item === "string" ? item : item[filterField]));
	}

	let animateContainerHeight = false;
	const slideInSpring = spring({ height: 0, width: 0 }, { stiffness: 0.2, damping: 0.7 });
	component_subscribe($$self, slideInSpring, value => $$invalidate(11, $slideInSpring = value));

	function setSpringDimensions(hard) {
		let maxHeightVar = getComputedStyle(document.documentElement).getPropertyValue("--svelte-helpers-auto-complete-results-max-height");
		let maxHeight = parseInt(maxHeightVar, 10);

		slideInSpring.set(
			{
				height: Math.min(resultsList.offsetHeight, maxHeight),
				width: Math.max(resultsList.offsetWidth, inputEl.clientWidth)
			},
			hard ? { hard: true } : void 0
		);
	}

	let itemsHeightObserver = new ResizeObserver(() => setSpringDimensions());

	let inputWidthObserver = new ResizeObserver(() => {
			$$invalidate(8, inputWidth = inputEl.clientWidth);
		});

	let resultsList;

	function opened() {
		setSpringDimensions(true);
		$$invalidate(10, animateContainerHeight = true);
		itemsHeightObserver.observe(resultsList);
	}

	function closing() {
		itemsHeightObserver.unobserve(resultsList);
		$$invalidate(10, animateContainerHeight = false);
	}

	function highlightItem(index) {
		index !== selectedIndex && $$invalidate(4, selectedIndex = index);
	}

	function unhighlightItem(index) {
		if (selectedIndex === index) {
			$$invalidate(4, selectedIndex = null);
		}
	}

	function onSelect(option) {
		if (onItemSelected) {
			onItemSelected(option, inputEl);
			$$invalidate(3, currentSearch = inputEl.value);
		} else if (typeof option === "string") {
			$$invalidate(7, inputEl.value = option, inputEl);
		} else {
			$$invalidate(7, inputEl.value = option[displayField], inputEl);
		}
	}

	function keyDown(evt) {
		if (!open && evt.keyCode == 40 && focused) {
			$$invalidate(6, open = true);
		} else if (open && filteredOptions.length) {
			if (evt.keyCode == 40) {
				if (selectedIndex == null) {
					$$invalidate(4, selectedIndex = 0);
				} else {
					$$invalidate(4, selectedIndex = selectedIndex == filteredOptions.length - 1
					? 0
					: selectedIndex + 1);
				}
			} else if (evt.keyCode == 38) {
				if (selectedIndex == null) {
					$$invalidate(4, selectedIndex = filteredOptions.length - 1);
				} else {
					$$invalidate(4, selectedIndex = selectedIndex == 0
					? filteredOptions.length - 1
					: selectedIndex - 1);
				}
			} else if (evt.keyCode == 13) {
				if (selectedIndex != null) {
					onSelect(filteredOptions[selectedIndex]);
					$$invalidate(6, open = false);
				}
			}
		}
	}

	onMount(() => {
		$$invalidate(8, inputWidth = inputEl.clientWidth);
		inputWidthObserver.observe(inputEl);

		return () => {
			inputWidthObserver.unobserve(inputEl);
		};
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(7, inputEl);
		});
	}

	function input_input_handler() {
		currentSearch = this.value;
		$$invalidate(3, currentSearch);
	}

	const click_handler = option => onSelect(option);
	const mousemove_handler = index => highlightItem(index);
	const mouseleave_handler = index => unhighlightItem(index);

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			resultsList = $$value;
			$$invalidate(5, resultsList);
		});
	}

	$$self.$$set = $$props => {
		if ("onItemSelected" in $$props) $$invalidate(22, onItemSelected = $$props.onItemSelected);
		if ("onBlur" in $$props) $$invalidate(23, onBlur = $$props.onBlur);
		if ("options" in $$props) $$invalidate(24, options = $$props.options);
		if ("placeholder" in $$props) $$invalidate(0, placeholder = $$props.placeholder);
		if ("inputStyles" in $$props) $$invalidate(1, inputStyles = $$props.inputStyles);
		if ("filterField" in $$props) $$invalidate(25, filterField = $$props.filterField);
		if ("displayField" in $$props) $$invalidate(2, displayField = $$props.displayField);
		if ("filterByStartsWith" in $$props) $$invalidate(26, filterByStartsWith = $$props.filterByStartsWith);
		if ("$$scope" in $$props) $$invalidate(27, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*currentSearch, options*/ 16777224) {
			 {
				$$invalidate(9, filteredOptions = currentSearch ? filterOptions(options) : options);
				$$invalidate(4, selectedIndex = null);
			}
		}

		if ($$self.$$.dirty[0] & /*resultsList, selectedIndex*/ 48) {
			 {
				if (resultsList && selectedIndex != null) {
					let allListItems = [...resultsList.querySelectorAll("li")];
					let li = allListItems[selectedIndex];
					li && li.scrollIntoView({ block: "nearest" });
				}
			}
		}
	};

	return [
		placeholder,
		inputStyles,
		displayField,
		currentSearch,
		selectedIndex,
		resultsList,
		open,
		inputEl,
		inputWidth,
		filteredOptions,
		animateContainerHeight,
		$slideInSpring,
		inputEngaged,
		inputChanged,
		inputBlurred,
		slideInSpring,
		opened,
		closing,
		highlightItem,
		unhighlightItem,
		onSelect,
		keyDown,
		onItemSelected,
		onBlur,
		options,
		filterField,
		filterByStartsWith,
		$$scope,
		slots,
		input_binding,
		input_input_handler,
		click_handler,
		mousemove_handler,
		mouseleave_handler,
		ul_binding
	];
}

class AutoSuggest extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1.getElementById("svelte-xuq0mx-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				onItemSelected: 22,
				onBlur: 23,
				options: 24,
				placeholder: 0,
				inputStyles: 1,
				filterField: 25,
				displayField: 2,
				filterByStartsWith: 26
			},
			[-1, -1]
		);
	}
}

export default AutoSuggest;
