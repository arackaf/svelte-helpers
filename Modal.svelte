import { SvelteComponent, init, safe_not_equal, element, append, create_slot, attr, insert, listen, update_slot, transition_in, add_render_callback, create_bidirectional_transition, transition_out, detach, create_in_transition, create_out_transition, binding_callbacks, create_component, mount_component, destroy_component, empty, group_outros, check_outros, destroy_each, component_subscribe, space, set_style } from 'svelte/internal';
import { onMount, afterUpdate } from 'svelte';
import { writable } from 'svelte/store';
import { sineOut, expoOut, quintIn } from 'svelte/easing';
import { fade } from 'svelte/transition';
import { springIn, springOut } from 'svelte-helpers/animation';

const modalStore = writable({
  modals: [],
});

/* src/Overlay.svelte generated by Svelte v3.29.0 */

function add_css() {
	var style = element("style");
	style.id = "svelte-24878w-style";
	style.textContent = ".svelte-modal-overlay{background:hsla(0, 0%, 0%, 0.33);position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;z-index:2}";
	append(document.head, style);
}

function create_fragment(ctx) {
	let div;
	let div_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "svelte-modal-overlay");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*overLayClicked*/ ctx[0]);
				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 250, easing: sineOut }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 250, easing: sineOut }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	let { onClose = () => {
		
	} } = $$props;

	let { modalNode } = $$props;

	function overLayClicked(evt) {
		let target = evt.target;

		do {
			if (target == modalNode) return;
		} while (target = target.parentNode);

		onClose();
	}

	$$self.$$set = $$props => {
		if ("onClose" in $$props) $$invalidate(1, onClose = $$props.onClose);
		if ("modalNode" in $$props) $$invalidate(2, modalNode = $$props.modalNode);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [overLayClicked, onClose, modalNode, $$scope, slots];
}

class Overlay extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-24878w-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { onClose: 1, modalNode: 2 });
	}
}

/* src/ModalInternal.svelte generated by Svelte v3.29.0 */

function create_fragment$1(ctx) {
	let div;
	let div_intro;
	let div_outro;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "modal");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[6](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, /*modalIn*/ ctx[1], {});
				div_intro.start();
			});

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, /*modalOut*/ ctx[2], {});
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[6](null);
			if (detaching && div_outro) div_outro.end();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	const { tickToValue: modalSpringIn, duration: springInDuration } = springIn(-30, 0, {
		stiffness: 0.1,
		damping: 0.35,
		precision: 0.01
	});

	const outSpring = {
		stiffness: 0.1,
		damping: 0.5,
		precision: 0.01
	};

	const { tickToValue: modalSpringOut, duration: springOutDuration } = springOut(0, 30, outSpring);
	let root;
	let { node } = $$props;

	onMount(() => {
		root.appendChild(node);
	});

	function modalIn() {
		return {
			duration: springInDuration,
			css: t => {
				const transformY = modalSpringIn(t);
				const opacity = expoOut(t);

				return `
          transform: translate3d(0px, ${transformY}px, 0px);
          opacity: ${opacity};
        `;
			}
		};
	}

	function modalOut() {
		return {
			duration: springOutDuration,
			css: t => {
				const easedTransform = modalSpringOut(t);
				const easedOpacity = quintIn(t);

				return `
          transform: translate3d(0px, ${easedTransform}px, 0px);
          opacity: ${easedOpacity}
        `;
			}
		};
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			root = $$value;
			$$invalidate(0, root);
		});
	}

	$$self.$$set = $$props => {
		if ("node" in $$props) $$invalidate(3, node = $$props.node);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [root, modalIn, modalOut, node, $$scope, slots, div_binding];
}

class ModalInternal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { node: 3 });
	}
}

/* src/ModalContainer.svelte generated by Svelte v3.29.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (9:2) <Overlay onClose={packet.onClose} modalNode={packet.node}>
function create_default_slot(ctx) {
	let modalinternal;
	let t;
	let current;
	modalinternal = new ModalInternal({ props: { node: /*packet*/ ctx[1].node } });

	return {
		c() {
			create_component(modalinternal.$$.fragment);
			t = space();
		},
		m(target, anchor) {
			mount_component(modalinternal, target, anchor);
			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modalinternal_changes = {};
			if (dirty & /*$modalState*/ 1) modalinternal_changes.node = /*packet*/ ctx[1].node;
			modalinternal.$set(modalinternal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modalinternal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modalinternal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modalinternal, detaching);
			if (detaching) detach(t);
		}
	};
}

// (8:0) {#each $modalState.modals as packet}
function create_each_block(ctx) {
	let overlay;
	let current;

	overlay = new Overlay({
			props: {
				onClose: /*packet*/ ctx[1].onClose,
				modalNode: /*packet*/ ctx[1].node,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(overlay.$$.fragment);
		},
		m(target, anchor) {
			mount_component(overlay, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const overlay_changes = {};
			if (dirty & /*$modalState*/ 1) overlay_changes.onClose = /*packet*/ ctx[1].onClose;
			if (dirty & /*$modalState*/ 1) overlay_changes.modalNode = /*packet*/ ctx[1].node;

			if (dirty & /*$$scope, $modalState*/ 17) {
				overlay_changes.$$scope = { dirty, ctx };
			}

			overlay.$set(overlay_changes);
		},
		i(local) {
			if (current) return;
			transition_in(overlay.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(overlay.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(overlay, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*$modalState*/ ctx[0].modals;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*$modalState*/ 1) {
				each_value = /*$modalState*/ ctx[0].modals;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $modalState;
	component_subscribe($$self, modalStore, $$value => $$invalidate(0, $modalState = $$value));
	return [$modalState];
}

class ModalContainer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
	}
}

const container = document.createElement("div");
document.body.appendChild(container);

const overlay = new ModalContainer({
  target: container,
});

/* src/Modal.svelte generated by Svelte v3.29.0 */

function add_css$1() {
	var style = element("style");
	style.id = "svelte-1rrhqot-style";
	style.textContent = ".svelte-modal-content{width:50vw;margin:10vh auto;background:white;padding:2rem;outline:none;max-width:600px;border-radius:5px;border:2px solid blue}@media(max-width: 1000px){.svelte-modal-content{width:55vw}}@media(max-width: 800px){.svelte-modal-content{width:60vw}}@media(max-width: 650px){.svelte-modal-content{width:70vw}}@media(max-width: 600px){.svelte-modal-content{width:80vw}}@media(max-width: 550px){.svelte-modal-content{width:90vw}}@media(max-width: 500px){.svelte-modal-content{width:95vw}}";
	append(document.head, style);
}

function create_fragment$3(ctx) {
	let div1;
	let div0;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "svelte-modal-content");
			set_style(div1, "display", "none");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[5](div0);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[5](null);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { open = false } = $$props;

	let { onClose = () => {
		
	} } = $$props;

	let contentNode;
	let currentlyOpen = false;
	onMount(sync);
	afterUpdate(sync);

	function sync() {
		if (!currentlyOpen && open) {
			currentlyOpen = true;

			modalStore.update(state => ({
				...state,
				modals: [...state.modals, { node: contentNode, onClose }]
			}));
		} else if (currentlyOpen && !open) {
			currentlyOpen = false;

			modalStore.update(state => ({
				...state,
				modals: state.modals.filter(d => d.node != contentNode)
			}));
		}
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			contentNode = $$value;
			$$invalidate(0, contentNode);
		});
	}

	$$self.$$set = $$props => {
		if ("open" in $$props) $$invalidate(1, open = $$props.open);
		if ("onClose" in $$props) $$invalidate(2, onClose = $$props.onClose);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [contentNode, open, onClose, $$scope, slots, div0_binding];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1rrhqot-style")) add_css$1();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { open: 1, onClose: 2 });
	}
}

export default Modal;
